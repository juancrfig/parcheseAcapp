[
  "Comprehensive Java Documentation for Exam Preparation\nThis documentation provides detailed explanations, syntax, methods, properties, and examples for key Java topics. It is designed to ensure your AI understands everything about these concepts, with a focus on clarity and practical code snippets.\n\nModule 2: Object-Oriented Programming and Data Structures\n1. Introduction to Object-Oriented Programming (OOP)\nOOP is a paradigm that organizes code around \"objects,\" instances of classes that encapsulate data (attributes) and behavior (methods).\n\nKey Concepts:\nClasses: Blueprints for objects, defining their structure and behavior.\nObjects: Instances of classes representing specific entities.\nAttributes: Variables that store an object’s state (e.g., color, model).\nMethods: Functions that define an object’s behavior (e.g., displayInfo()).\n\n\nAdvantages:\nModularity: Independent object code.\nReusability: Objects reusable across programs.\nMaintainability: Easier updates.\nAbstraction: Focus on \"what\" not \"how.\"\n\n\n\nSyntax Example:\n// Define a class\npublic class Car {\n    // Attributes (properties)\n    String color;  // Stores the car's color\n    String model;  // Stores the car's model\n\n    // Method to display car info\n    void displayInfo() {\n        System.out.println(\"Model: \" + model + \", Color: \" + color);\n    }\n\n    // Main method to test the class\n    public static void main(String[] args) {\n        Car myCar = new Car();  // Create an object\n        myCar.model = \"Toyota\";  // Set attribute value\n        myCar.color = \"Red\";     // Set attribute value\n        myCar.displayInfo();     // Call method, Output: Model: Toyota, Color: Red\n    }\n}\n\n2. Encapsulation\nEncapsulation hides an object’s internal state, exposing only necessary methods to interact with it, typically via getters and setters.\n\nAccess Modifiers:\npublic: Accessible everywhere.\nprivate: Accessible only within the class.\nprotected: Accessible in package and subclasses.\ndefault (no modifier): Package-private.\n\n\nMethods:\nGetters: Retrieve private attribute values (e.g., getName()).\nSetters: Modify private attribute values with validation (e.g., setAge()).\n\n\n\nSyntax Example:\npublic class Person {\n    private String name;  // Private attribute for name\n    private int age;      // Private attribute for age\n\n    // Getter for name\n    public String getName() {\n        return name;\n    }\n\n    // Setter for name\n    public void setName(String name) {\n        this.name = name;  // 'this' distinguishes instance variable from parameter\n    }\n\n    // Getter for age\n    public int getAge() {\n        return age;\n    }\n\n    // Setter for age with validation\n    public void setAge(int age) {\n        if (age > 0) {  // Ensure age is positive\n            this.age = age;\n        }\n    }\n\n    public static void main(String[] args) {\n        Person person = new Person();\n        person.setName(\"Alice\");  // Set name\n        person.setAge(30);        // Set age\n        System.out.println(\"Name: \" + person.getName() + \", Age: \" + person.getAge());\n        // Output: Name: Alice, Age: 30\n    }\n}\n\n3. Inheritance and Polymorphism\n\nInheritance: A subclass inherits attributes and methods from a superclass using extends.\nTypes: Single (one parent), Multilevel (chain of inheritance), Hierarchical (multiple children).\n\n\nPolymorphism: Objects can take multiple forms.\nMethod Overloading: Same method name, different parameters (compile-time).\nMethod Overriding: Subclass redefines superclass method (runtime, uses @Override).\nAbstract Classes: Cannot be instantiated, define methods for subclasses.\nInterfaces: Contracts for methods subclasses must implement.\n\n\n\nSyntax Example:\n// Superclass\npublic class Animal {\n    public void makeSound() {\n        System.out.println(\"Some generic sound\");\n    }\n}\n\n// Subclass inheriting from Animal\npublic class Dog extends Animal {\n    @Override  // Indicates method override\n    public void makeSound() {\n        System.out.println(\"Bark\");  // Overrides superclass method\n    }\n\n    public static void main(String[] args) {\n        Animal myDog = new Dog();  // Polymorphism: Animal reference, Dog object\n        myDog.makeSound();         // Output: Bark (runtime polymorphism)\n    }\n}\n\n4. Relationships between Classes\n\nAssociation: General relationship between objects.\nAggregation: \"Has-a\" relationship, parts can exist independently (e.g., Car has an Engine).\nComposition: Stronger \"part-of\" relationship, parts cannot exist without the whole (e.g., House and Room).\nDependency: Temporary use of another class.\nRealization: Implements an interface.\n\nSyntax Example (Aggregation):\npublic class Engine {\n    String type = \"V6\";  // Engine attribute\n}\n\npublic class Car {\n    private Engine engine;  // Aggregation: Car has-an Engine\n\n    public Car(Engine engine) {\n        this.engine = engine;  // Constructor injects Engine\n    }\n\n    public void showEngine() {\n        System.out.println(\"Engine Type: \" + engine.type);\n    }\n\n    public static void main(String[] args) {\n        Engine engine = new Engine();\n        Car myCar = new Car(engine);\n        myCar.showEngine();  // Output: Engine Type: V6\n    }\n}\n\n5. Sets, Maps, Enumerations, and Exceptions\n\nSets: Collections without duplicates (java.util.Set).\nHashSet: Unordered, fast access.\nTreeSet: Sorted order.\nLinkedHashSet: Maintains insertion order.\nMethods: add(), remove(), contains(), size().\n\n\nMaps: Key-value pairs (java.util.Map).\nHashMap: Unordered.\nTreeMap: Sorted by keys.\nLinkedHashMap: Maintains insertion order.\nMethods: put(), get(), remove(), keySet().\n\n\nEnumerations (Enums): Fixed constants.\nProperties: Implicitly public static final.\nMethods: values(), valueOf().\n\n\nExceptions: Error handling.\ntry-catch: Handles exceptions.\nthrow: Throws custom exceptions.\nthrows: Declares exceptions in method signature.\n\n\n\nSyntax Example:\nimport java.util.*;\n\npublic class CollectionsExample {\n    public static void main(String[] args) {\n        // Set\n        Set<String> set = new HashSet<>();\n        set.add(\"Apple\");    // Add element\n        set.add(\"Banana\");\n        System.out.println(\"Set: \" + set);  // Output: Set: [Apple, Banana]\n\n        // Map\n        Map<String, Integer> map = new HashMap<>();\n        map.put(\"Apple\", 1);  // Add key-value pair\n        map.put(\"Banana\", 2);\n        System.out.println(\"Map: \" + map);  // Output: Map: {Apple=1, Banana=2}\n\n        // Enum\n        enum Day { MONDAY, TUESDAY, WEDNESDAY }\n        Day today = Day.MONDAY;\n        System.out.println(\"Today: \" + today);  // Output: Today: MONDAY\n\n        // Exception\n        try {\n            int result = divide(10, 0);\n        } catch (ArithmeticException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            // Output: Error: Cannot divide by zero\n        }\n    }\n\n    static int divide(int a, int b) throws ArithmeticException {\n        if (b == 0) {\n            throw new ArithmeticException(\"Cannot divide by zero\");\n        }\n        return a / b;\n    }\n}\n\n\nModule 3: Design Principles and Patterns\n1. Design Principles (SOLID)\n\nS (Single Responsibility): One class, one purpose.\nO (Open-Closed): Extendable without modification.\nL (Liskov Substitution): Subclasses replaceable for superclasses.\nI (Interface Segregation): Specific, small interfaces.\nD (Dependency Inversion): Depend on abstractions.\n\nSyntax Example (Single Responsibility):\npublic class UserManager {\n    public void addUser(String name) {\n        System.out.println(\"User added: \" + name);\n    }\n}\n\npublic class EmailSender {\n    public void sendEmail(String message) {\n        System.out.println(\"Email sent: \" + message);\n    }\n\n    public static void main(String[] args) {\n        UserManager um = new UserManager();\n        um.addUser(\"Alice\");  // Output: User added: Alice\n        EmailSender es = new EmailSender();\n        es.sendEmail(\"Hello\");  // Output: Email sent: Hello\n    }\n}\n\n2. Design Patterns (Creational)\n\nSingleton: One instance globally.\nMethods: getInstance().\n\n\nFactory Method: Flexible object creation.\nAbstract Factory: Creates related object families.\nBuilder: Step-by-step construction.\nPrototype: Clones existing objects.\n\nSyntax Example (Singleton):\npublic class Singleton {\n    private static Singleton instance;  // Private static instance\n\n    private Singleton() {}  // Private constructor\n\n    public static Singleton getInstance() {  // Public access method\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n\n    public void showMessage() {\n        System.out.println(\"Singleton instance\");\n    }\n\n    public static void main(String[] args) {\n        Singleton s = Singleton.getInstance();\n        s.showMessage();  // Output: Singleton instance\n    }\n}\n\n3. Design Patterns (Structural)\n\nAdapter: Bridges incompatible interfaces.\nBridge: Separates abstraction/implementation.\nComposite: Tree-like hierarchies.\nDecorator: Adds behavior dynamically.\nFacade: Simplifies subsystems.\nFlyweight: Shares lightweight objects.\nProxy: Controls object access.\n\nSyntax Example (Adapter):\ninterface MediaPlayer {\n    void play(String type, String file);\n}\n\nclass VlcPlayer {\n    public void playVlc(String file) {\n        System.out.println(\"VLC playing: \" + file);\n    }\n}\n\nclass MediaAdapter implements MediaPlayer {\n    VlcPlayer vlc = new VlcPlayer();\n\n    public void play(String type, String file) {\n        if (type.equals(\"vlc\")) {\n            vlc.playVlc(file);\n        }\n    }\n\n    public static void main(String[] args) {\n        MediaPlayer player = new MediaAdapter();\n        player.play(\"vlc\", \"movie.vlc\");  // Output: VLC playing: movie.vlc\n    }\n}\n\n4. Design Patterns (Behavioral)\n\nObserver: Notifies changes to subscribers.\nStrategy: Interchangeable algorithms.\nCommand: Encapsulates requests.\nIterator: Sequential collection access.\n\nSyntax Example (Observer):\nimport java.util.ArrayList;\nimport java.util.List;\n\ninterface Observer {\n    void update();\n}\n\nclass Subject {\n    private List<Observer> observers = new ArrayList<>();\n\n    public void addObserver(Observer o) {\n        observers.add(o);\n    }\n\n    public void notifyObservers() {\n        for (Observer o : observers) {\n            o.update();\n        }\n    }\n}\n\nclass ConcreteObserver implements Observer {\n    public void update() {\n        System.out.println(\"State changed!\");\n    }\n\n    public static void main(String[] args) {\n        Subject subject = new Subject();\n        ConcreteObserver observer = new ConcreteObserver();\n        subject.addObserver(observer);\n        subject.notifyObservers();  // Output: State changed!\n    }\n}\n\n\nModule 4: Concurrency in Java\n1. Introduction to Concurrency\nConcurrency enables multiple tasks to run simultaneously using threads.\n\nThread Creation:\nExtend Thread or implement Runnable.\n\n\nKey Methods:\nstart(): Begins thread execution.\nrun(): Defines thread’s task.\nsleep(): Pauses execution.\n\n\n\nSyntax Example:\nclass MyThread implements Runnable {\n    public void run() {\n        System.out.println(\"Thread running\");\n    }\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(new MyThread());\n        thread.start();  // Output: Thread running\n    }\n}\n\n2. Thread Synchronization and Atomic Processes\n\nSynchronized: Prevents concurrent access issues.\nKeyword: synchronized.\n\n\nLocks: Fine-grained control (java.util.concurrent.locks.Lock).\nAtomic Classes: Thread-safe operations (e.g., AtomicInteger).\n\nSyntax Example:\nclass Counter {\n    private int count = 0;\n\n    public synchronized void increment() {  // Thread-safe method\n        count++;\n    }\n\n    public int getCount() {\n        return count;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Counter counter = new Counter();\n        Thread t1 = new Thread(() -> { for (int i = 0; i < 1000; i++) counter.increment(); });\n        Thread t2 = new Thread(() -> { for (int i = 0; i < 1000; i++) counter.increment(); });\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n        System.out.println(\"Count: \" + counter.getCount());  // Output: Count: 2000\n    }\n}\n\n\nModule 5: Data Persistence\n1. File Handling in Java\nHandles reading/writing files using streams.\n\nClasses:\nBufferedReader: Reads text efficiently.\nBufferedWriter: Writes text efficiently.\n\n\nMethods:\nreadLine(): Reads a line of text.\nwrite(): Writes text.\n\n\n\nSyntax Example:\nimport java.io.*;\n\nclass FileHandler {\n    public static void main(String[] args) throws IOException {\n        // Writing to a file\n        BufferedWriter writer = new BufferedWriter(new FileWriter(\"output.txt\"));\n        writer.write(\"Hello, Java!\");\n        writer.close();\n\n        // Reading from a file\n        BufferedReader reader = new BufferedReader(new FileReader(\"output.txt\"));\n        String line = reader.readLine();\n        System.out.println(line);  // Output: Hello, Java!\n        reader.close();\n    }\n}\n\n2. Java Database Connectivity (JDBC)\nConnects Java to databases.\n\nKey Classes:\nConnection: Establishes database connection.\nStatement: Executes SQL queries.\nResultSet: Holds query results.\n\n\nMethods:\ngetConnection(): Connects to DB.\nexecuteQuery(): Runs SELECT queries.\n\n\n\nSyntax Example:\nimport java.sql.*;\n\nclass DatabaseExample {\n    public static void main(String[] args) throws SQLException {\n        String url = \"jdbc:mysql://localhost:3306/mydb\";\n        Connection conn = DriverManager.getConnection(url, \"user\", \"password\");\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.executeQuery(\"SELECT name FROM users\");\n        while (rs.next()) {\n            System.out.println(rs.getString(\"name\"));\n        }\n        conn.close();\n    }\n}\n\n\nModule 6: Lambdas and Stream API\n1. Lambda Expressions\nAnonymous functions for functional interfaces.\n\nSyntax: (params) -> expression\nFunctional Interface: Single abstract method (e.g., Predicate).\nMethods: Depends on interface (e.g., test() for Predicate).\n\nSyntax Example:\nimport java.util.function.Predicate;\n\nclass LambdaExample {\n    public static void main(String[] args) {\n        Predicate<String> startsWithA = s -> s.startsWith(\"A\");  // Lambda\n        System.out.println(startsWithA.test(\"Alice\"));  // Output: true\n        System.out.println(startsWithA.test(\"Bob\"));    // Output: false\n    }\n}\n\n2. Stream API\nProcesses collections functionally.\n\nOperations:\nIntermediate: filter(), map() (returns stream).\nTerminal: collect(), forEach() (produces result).\n\n\nMethods:\nstream(): Creates a stream.\nfilter(): Filters elements.\n\n\n\nSyntax Example:\nimport java.util.*;\nimport java.util.stream.*;\n\nclass StreamExample {\n    public static void main(String[] args) {\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\n        numbers.stream()\n               .filter(n -> n % 2 == 0)  // Keep even numbers\n               .forEach(System.out::println);  // Output: 2, 4\n    }\n}\n\nString and Date Manipulation in Java\nThis document provides an overview of key methods and properties (characteristics) for manipulating strings and dates in Java. The String class is used for text handling, while the modern java.time package (introduced in Java 8) is used for date and time operations.\n\nString Manipulation\nThe String class in Java represents immutable sequences of characters, widely used for text processing.\nKey Properties of Strings\n\nImmutability: Once created, a String cannot be modified; operations like replacement create a new String.\nThread Safety: Immutability ensures strings are safe to use across threads without synchronization.\nUTF-16 Encoding: Strings are stored internally as UTF-16 encoded characters.\nConcatenation: Strings can be combined using the + operator or the concat() method.\n\nEssential String Methods\nHere are some of the most useful methods for string manipulation:\n\nlength()  \n\nReturns the number of characters in the string.  \nSyntax: int length()  \nExample: \"Hello\".length() returns 5.\n\n\ncharAt(int index)  \n\nReturns the character at the specified index (0-based).  \nSyntax: char charAt(int index)  \nExample: \"Hello\".charAt(1) returns 'e'.\n\n\nsubstring(int beginIndex, int endIndex)  \n\nExtracts a substring from beginIndex to endIndex - 1.  \nSyntax: String substring(int beginIndex, int endIndex)  \nExample: \"Hello World\".substring(0, 5) returns \"Hello\".\n\n\nindexOf(String str)  \n\nReturns the index of the first occurrence of str, or -1 if not found.  \nSyntax: int indexOf(String str)  \nExample: \"Hello World\".indexOf(\"World\") returns 6.\n\n\ntoLowerCase()  \n\nConverts all characters to lowercase.  \nSyntax: String toLowerCase()  \nExample: \"HELLO\".toLowerCase() returns \"hello\".\n\n\ntoUpperCase()  \n\nConverts all characters to uppercase.  \nSyntax: String toUpperCase()  \nExample: \"hello\".toUpperCase() returns \"HELLO\".\n\n\ntrim()  \n\nRemoves leading and trailing whitespace.  \nSyntax: String trim()  \nExample: \"  Hello  \".trim() returns \"Hello\".\n\n\nreplace(char oldChar, char newChar)  \n\nReplaces all occurrences of oldChar with newChar.  \nSyntax: String replace(char oldChar, char newChar)  \nExample: \"Hello\".replace('l', 'p') returns \"Heppo\".\n\n\nsplit(String regex)  \n\nSplits the string into an array based on a regular expression.  \nSyntax: String[] split(String regex)  \nExample: \"apple,banana\".split(\",\") returns [\"apple\", \"banana\"].\n\n\n\n\nDate Manipulation\nJava’s java.time package provides modern, robust classes for date and time manipulation, such as LocalDate, LocalTime, and LocalDateTime. These classes are immutable and thread-safe.\nKey Properties of Date and Time Classes\n\nImmutability: Modifications create new instances rather than altering existing ones.\nThread Safety: Safe for concurrent use due to immutability.\nSeparation: Distinct classes for date (LocalDate), time (LocalTime), and combined date-time (LocalDateTime).\nTime Zone Support: Use ZonedDateTime for time zone-aware operations (not covered here).\n\nEssential Date and Time Methods\nLocalDate (Date without time)\n\nLocalDate.now()  \n\nReturns the current date.  \nSyntax: static LocalDate now()  \nExample: LocalDate.now() might return 2023-10-15.\n\n\nLocalDate.of(int year, int month, int dayOfMonth)  \n\nCreates a specific date.  \nSyntax: static LocalDate of(int year, int month, int dayOfMonth)  \nExample: LocalDate.of(2023, 10, 15) returns 2023-10-15.\n\n\nplusDays(long daysToAdd)  \n\nAdds days to the date.  \nSyntax: LocalDate plusDays(long daysToAdd)  \nExample: LocalDate.of(2023, 10, 15).plusDays(5) returns 2023-10-20.\n\n\ngetDayOfWeek()  \n\nReturns the day of the week.  \nSyntax: DayOfWeek getDayOfWeek()  \nExample: LocalDate.of(2023, 10, 15).getDayOfWeek() returns SUNDAY.\n\n\n\nLocalTime (Time without date)\n\nLocalTime.now()  \n\nReturns the current time.  \nSyntax: static LocalTime now()  \nExample: LocalTime.now() might return 14:30:00.\n\n\nLocalTime.of(int hour, int minute)  \n\nCreates a specific time.  \nSyntax: static LocalTime of(int hour, int minute)  \nExample: LocalTime.of(14, 30) returns 14:30:00.\n\n\n\nLocalDateTime (Date and time combined)\n\nLocalDateTime.now()  \n\nReturns the current date and time.  \nSyntax: static LocalDateTime now()  \nExample: LocalDateTime.now() might return 2023-10-15T14:30:00.\n\n\nLocalDateTime.of(int year, int month, int dayOfMonth, int hour, int minute)  \n\nCreates a specific date and time.  \nSyntax: static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute)  \nExample: LocalDateTime.of(2023, 10, 15, 14, 30) returns 2023-10-15T14:30:00.\n\n\n\nDateTimeFormatter (Formatting dates)\n\nDateTimeFormatter.ofPattern(String pattern)  \nCreates a formatter for custom date/time patterns.  \nSyntax: static DateTimeFormatter ofPattern(String pattern)  \nExample: LocalDate date = LocalDate.of(2023, 10, 15);\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\nString formatted = date.format(formatter);  // Returns \"15/10/2023\"\n"
]